---
date: 2024-08-29
modified: 2024-08-31T17:47:27+02:00
---

The philosophical idea behind **Abstraction** is that it's a way to **summarize complexity**. A sailboat and an airplane have a common, abstract relationship of being vehicles, but they differ a lot as vehicles. In Python, we have two approaches to defining similar things:
* **Duck Typing** (already discussed [here](Books/Python%20Object-Oriented%20Programming/03.%20When%20Objects%20Are%20Alike.md#1.%20Duck%20Typing)): briefly "*If looks like a duck and quacks like a duck, it must be a duck*".
* **Inheritance**: when two class definitions have common aspects, a subclass can share common features of a superclass. The implementation details of the two classes may vary, but the classes should be interchangeable when we use the common features defined by the superclass.

We can take **Inheritance** one step further: we can have superclass definition that are **Abstract**, meaning that they're not directly usable, but they can be used through inheritance to create concrete class. Let's make a visual example of inheritance:

![](Books/Python%20Object-Oriented%20Programming/attachments/python-oop.drawio%20(2).svg)

+ our base class `BaseClass` has a special class, `abc.ABC` as parent class. This provides some special metaclass features that help make sure the concrete class have replaces the abstractions;
+ the abstract `BaseClass` has an abstract method, `a_method()`, which doesn't have an implementation and a subclass must provide this;
+ the two concrete classes, `ConcreteClass_1` and `ConcreteClass_2`, extends the abstract `BaseClass` and they provide a concrete implementation of the abstract `a_method()` method.
# 1. Creating an abstract base class
