---
date: 2024-06-26
modified: 2024-06-26T23:09:55+02:00
---
While the software is highly predictable, the **runtime context can provide unexpected inputs and situations**. A possible solution to this problem is based on **Exceptions**, that are **special error objects raised when a normal response is impossible**.
# Raising Exceptions
Python's normal behaviour is to execute statements in the order they are found. A few statement, such as `if`, `while`, and `for`, alter the simple top-to-bottom sequence of statement execution. Additionally, an **Exception** can break the sequential flow of execution. Exceptions are raised, and this interrupts the sequential execution of statements.
In Python, the exception that is raised is also an **object**. There are many different exception classes available, but they all extends a built-in class called `BaseException`.
Here's some example of exceptions potentially raised:
``` terminal {1,8,16,17}
>>> print "hello world"
Cell In[61],   line 1
    print "hello world"
    ^
SyntaxError: Missing parentheses in call to 'print'. Did you mean print(...)?


>>> x = 5/0
ZeroDivisionError                         Traceback (most recent call last)
Cell In[62], line 1
----> 1 x = 5/0

ZeroDivisionError: division by zero


>>> lst = [1,2,3]
>>> print(lst[3])
IndexError                                Traceback (most recent call last)
Cell In[63], line 2
      1 lst = [1,2,3]
----> 2 print(lst[3])

IndexError: list index out of range
```

* Some exceptions are indicators of something clearly wrong in the program, such as `SyntaxError` and `NameError`: in these cases we need to find the indicated line number and fix the problem.
* Others are design-problem, such as `ZeroDivisionError`: once gone to the indicated line, we need to work backwards from there to find out what caused the problem that raised the exceptions.
> [!note]
> All of Python's built-in exceptions end with the name `Error`. That's because in Python, the words **error** and **exceptions** are used almost interchangeably.

## Raising and Exception
Let's write a function that inform the user that the inputs are invalid. In particular, we want to add items to a list only if they're even-numbered integers and we'll do that by extending the built-in `List` and overriding the `append` method:
```python
from typing import List

class EvenOnly(List[int]):
    def append(self, value: int) -> None:
        if not isinstance(value, int):
            raise TypeError("Only integers can be added.")
        if value % 2 != 0:
            raise ValueError("Only even numbers can be added")
        super().append(value)
        

e = EvenOnly()
```
Let's see if it works:
``` terminal {1,18}
>>> e.append("hello")
TypeError                                 Traceback (most recent call last)
Cell In[78], line 13
      9         super().append(value)
     12 e = EvenOnly()
---> 13 e.append("hello")

Cell In[78], line 6
      4 def append(self, value: int) -> None:
      5     if not isinstance(value, int):
----> 6         raise TypeError("Only integers can be added.")
      7     if value % 2 != 0:
      8         raise ValueError("Only even numbers can be added")

TypeError: Only integers can be added.


>>> e.append(3)
ValueError                                Traceback (most recent call last)
Cell In[81], line 1
----> 1 e.append(3)

Cell In[80], line 8
      6     raise TypeError("Only integers can be added.")
      7 if value % 2 != 0:
----> 8     raise ValueError("Only even numbers can be added.")
      9 super().append(value)

ValueError: Only even numbers can be added.
```
## The effect of an Exception
When an exception is raised, it stops the program execution immediately. Any lines that were supposed to run after the exception is raised are not executed, and unless the exception is handled by an `except` clause, the program will exit with an error message.
An example:
```python
def never_returns():
    print("I am about to raise an exception.")
    raise Exception("This is always raised.")
    print("This line will never execute.")
    return "I won't be returned."

never_returns()
```
Output:
```
I am about to raise an exception.
---------------------------------------------------------------------------
Exception                                 Traceback (most recent call last)
Cell In[82], line 7
      4     print("This line will never execute.")
      5     return "I won't be returned."
----> 7 never_returns()

Cell In[82], line 3
      1 def never_returns():
      2     print("I am about to raise an exception.")
----> 3     raise Exception("This is always raised.")
      4     print("This line will never execute.")
      5     return "I won't be returned."

Exception: This is always raised.
```
Or, a more complex one:
```python
def never_returns():
    print("I am about to raise an exception.")
    raise Exception("This is always raised.")
    print("This line will never execute.")
    return "I won't be returned."

def call_exceptor():
    print("Call exceptor start here...")
    never_returns()
    print("An exception was raised...")
    print("... so these lines don't run")

call_exceptor()
```
Output:
```terminal {}
Call exceptor start here...
I am about to raise an exception.
---------------------------------------------------------------------------
Exception                                 Traceback (most recent call last)
Cell In[83], line 13
     10     print("An exception was raised...")
     11     print("... so these lines don't run")
---> 13 call_exceptor()

Cell In[83], line 9
      7 def call_exceptor():
      8     print("Call exceptor start here...")
----> 9     never_returns()
     10     print("An exception was raised...")
     11     print("... so these lines don't run")

Cell In[83], line 3
      1 def never_returns():
      2     print("I am about to raise an exception.")
----> 3     raise Exception("This is always raised.")
      4     print("This line will never execute.")
      5     return "I won't be returned."

Exception: This is always raised.
```
## Handling Exceptions
Now we need a way to handle exceptions. We'll do that by wrapping any code that might throw one:
```python
try:
    never_returns()
    print("Never Executed")
except Exception as ex:
    print(f"I caught an exception: {ex!r}")
print("Executed after the exception.")
```
Output:
```
I am about to raise an exception.
I caught an exception: Exception('This is always raised.')
Executed after the exception.
```
Explaination:
* The `never_returns()` function raises an exception, specifically an `Exception`;
* The `except` clause catches the `Exception` exception;
* Once caught, we are able to handle it by printing the string at line `5`, and continue on our way.

> [!attention]
> The problem with the preceding code is that it uses the `Exception` class to **match any type of exception**.

