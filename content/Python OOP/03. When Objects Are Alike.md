---
date: 2024-06-19
modified: 2024-06-23T20:51:04+02:00
---
In the programming world, **Duplicate Code** is considered evil. There are many ways to merge pieces of code or objects that have similar functionality. One of them is **Inheritance**.

>[!definition]
>**Inheritance** allows us to create "**IS-A**" relationship between two or more classes, abstracting common logic into superclasses and extending the superclass with specific details in each subclass.

# Basic Inheritance
Technically, every class we create uses **Inheritance**.
>[!info]
>**All Python classes are subclasses of the special built-in class** named **`object`**.

This class provide a little bit of metadata and a few built-in behaviours (such as `__init__`, `__str__`, and `__repr__`, among others.) so Python can treat all objects consistently. To prove that:
```python
class MyClass:
    pass
    
print(issubclass(MyClass, object)) # This will print: True
```

In Python 3, all classes automatically inherit from `object` if we don't explicitly provide a different **superclass** (or **parent class**).
* The **Superclass** is the class that is being inherited from.
* The **Subclass** is the class that inherits from the superclass. it is said that the subclass **extends** the parent class.

Let's see some uses of inheritance
### Add functionality to an existing class:
Let's create the `Contact` class:
```python
from typing import List

class Contact:
    all_contacts: List["Contact"] = []

    def __init__(self, name: str, email: str) -> None:
        self.name = name
        self.email = email
        Contact.all_contacts.append(self)

    def __repr__(self):
        return f"{self.__class__.__name__}({self.name!r}, {self.email!r})"


contact1 = Contact("John Doe", "john@example.com")
contact2 = Contact("Jane Doe", "jane@example.com")

print(Contact.all_contacts)
```
Output:
```
[Contact('John Doe', 'john@example.com'), Contact('Jane Doe', 'jane@example.com')]
```
Among all the contacts there could be some that are suppliers that we need to order supplies from. We could add an `order` method to the `Contact` class, but that would allow people to order things from contacts that are not suppliers. Solution: **create a new `Supplier` class** that acts like `Contact` class, but **has an additional `order` method** that accepts a yet-to-be defined `Order` object:
```python
class Supplier(Contact):
    def order(self, order: "Order") -> None:
        print("{order} send to '{self.name}'")
```
With this setup, all the contacts, including suppliers, accept a name and email address in their constructor, but only `Supplier` instances have he `order` method:
```python
c = Contact("AContactName", "acontact@gmail.com")
s = Supplier("ASupplierName", "asupplier@gmail.com")

pprint(c.all_contacts)
print()
s.order("I need pliers")
```
Output:
```
[Contact('John Doe', 'john@example.com'),
 Contact('Jane Doe', 'jane@example.com'),
 Contact('AContactName', 'acontact@gmail.com'),
 Supplier('ASupplierName', 'asupplier@gmail.com')]

I need pliers send to 'ASupplierName'
```

> [!info] Class Variable
> A **Class Variable** is shared by all instances of this class and it has collected instance of both `Contact` and `Supplier` classes.
### Extending built-ins
#### Example 1: Extending `list`
How to search a specific name within the list of contacts? Instead of instantiating a generic list as our class variable, we create a new `ContactList` class that **extends the built-in `list` data type**:
```python
from __future__ import annotations
from typing import List


class ContactList(list["Contact"]):
    def search(self, name: str) -> list["Contact"]:
        matching_contacts: list["Contact"] = []
        for contact in self:
            if name in contact.name:
                matching_contacts.append(contact)
        return matching_contacts
    
class Contact:
    all_contacts = ContactList()

    def __init__(self, name: str, email: str) -> None:
        self.name = name
        self.email = email
        Contact.all_contacts.append(self)

    def __repr__(self):
        return f"{self.__class__.__name__}({self.name!r}, {self.email!r})"


contact1 = Contact("John Doe", "john@example.com")
contact2 = Contact("Jane Doe", "jane@example.com")
contact2 = Contact("Mary Jane", "mary@example.com")

[c.name for c in Contact.all_contacts.search("Doe")]
```
Output:
```
['John Doe', 'Jane Doe']
```
#### Example 2: Extending `dict`
How to tracks the longest key in a dictionary?
```python
from typing import Optional

class LongNameDict(dict[str, int]):
    def longest_key(self) -> Optional[str]:
        longest = None
        for key in self:
            if longest is None or len(key) > len(longest):
                longest = key
        return longest
    

articles_read = LongNameDict()
articles_read["lucy"] = 42
articles_read["c_c_phillips"] = 6
articles_read["steve"]= 7

articles_read.longest_key()
```
Output:
```
'c_c_phillips'
```
You can also use a more generic dictionary with either strings or integers:
```python
from typing import Union

class LongNameDict(dict[str, Union[str, int]]):
	...
```
## Overriding and `super()`
Inheritance is great for adding new behaviour, as we have already seen, and for **changing behaviour** too.
It's possible to make a third variable available on initialization by overriding the `__init__()` method:
```python
class Friend(Contact):
	def __init__(self, name: str, email: str, phone: str) -> None:
		self.name = name
		self.email = email
		self.phone = phone
```
But that's not the best solution since duplicated code is created. Indeed we need a way to execute the original `__init__()` method on the `Contact` class from inside the new `Friend` class:
```python
class Friend(Contact):
	def __init__(self, name: str, email: str, phone: str) -> None:
		super().__init__(name, email)
		self.phone = phone

	def __repr__(self):
        return f"{self.__class__.__name__}({self.name!r}, {self.email!r}, {self.phone!r})"


aFriend = Friend("tizio", "tizio@gmail.com", "123456789")
Contact.all_contacts
```
Output:
```
[Contact('John Doe', 'john@example.com'),
 Contact('Jane Doe', 'jane@example.com'),
 Contact('Mary Jane', 'mary@example.com'),
 Friend('tizio', 'tizio@gmail.com', '123456789')]
```
Note that we have also overridden the `__repr__()` method to guarantee a proper visualization of the new `Friend` class instances.
# Multiple Inheritance
to-do
# Polymorphism
Polymorphism definition: different behaviours happen depending on which subclass is being used, wihouth having to explicitly know what the subclass actually is.