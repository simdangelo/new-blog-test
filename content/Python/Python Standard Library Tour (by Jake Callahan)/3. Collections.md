---
date: 2024-11-10
modified: 2024-11-10T21:55:27+01:00
---
Here we're going to see `collections` module. This module has a great assortment of data types. We'll break it down into three main sections:
1. `namedtuple`, `deque`, `Counter`
2. `ChainMap`, `defaultdict`, `OrderedDict`
3. `UserDict`, `UserList`, `UserStr`

# 1. `namedtuple`, `deque`, `Counter`
## 1.1. `namedtuple`
Tuples are common in Python and offer great functionality, but can be a little confusing when you're picking specific data out of them using indices. Let's look at this example that describes a book with title, author, and publication date and we want to pull data out of it:
```terminal
>>> bnw = ("Brave New World", "Aldous Huxley", 1931)

>>> title = bnw[0]
>>> author = bnw[1]
>>> publication_date = bnw[2]
```

Sometimes it's hard to understand what each position corresponds to. There are a few alternatives to this: construct a dictionary, create a new class, or use `namedtuple`. Let's re-create the same previous example:
```python
from collections import namedtuple

Book = namedtuple("Book", ["title", "author", "year"])
bnw = Book("Brave New World", "Aldous Huxley", 1931)
```
where in `namedtuple` constructor we listed the positional entries for each field. Now, we're able to pull out data from this data structure with dot notation:
```terminal
>>> bnw.author
'Aldous Huxley'

>>> bnw.title
'Brave New World'

>>> bnw.year
1931
```

Note that you can convert a `namedtuple` into a dictionary with `_asdict()` method:
```terminal
>>> bnw._asdict()
{'title': 'Brave New World', 'author': 'Aldous Huxley', 'year': 1931}
```
## 1.2. `deque`
This data structure is basically a list-like container with fast appends and pops on either end of it, which is most commonly used for flexible stacks and queues. Let's look at an example (`deque` accepts an iterable as argument):
```python
from collections import deque

dq = deque((3,4,5))
```

`deque` allows us to operate on both ends of it. For instance we can use `append()` and `appendleft()` methods:
```terminal
>>> dq.append(6)
>>> dq.appendleft(2)

>>> dq
deque([2, 3, 4, 5, 6])
```

And still use `pop()` and `popleft()`:
```terminal
>>> dq.pop()
>>> dq.popleft()

>>> dq
deque([3, 4, 5])
```

Now we exploit these features to create a new function checking if a word is a palindrome:
```python
def is_palindrome(word):
    dq = deque(word)
    while len(dq) > 1:
        if dq.popleft() != dq.pop():
            return False
    return True
```

Then:
```terminal
>>> is_palindrome("racecar")
True

>>> is_palindrome("alphabet")
False
```
## 1.3. `Counter`
The core functionality of `Counter` is pretty simple: just pass some iterable in and we get a counter object back:
```terminal
>>> from collections import Counter

>>> Counter("Hello world!")
Counter({'l': 3,
         'o': 2,
         'H': 1,
         'e': 1,
         ' ': 1,
         'w': 1,
         'r': 1,
         'd': 1,
         '!': 1})
```
What is telling us is how many times it encountered a single element within that iterable and, since strings are broken down by default on a per character basis, it's going to give us the amount of times that encountered each of these characters.

We also could have done the same thing by splitting it into individual words (splitting a string returns a list of words, which is still an iterable):
```terminal
>>> Counter("Hello world!".split())
Counter({'Hello': 1, 'world!': 1}) 
```

`Counter` objects have a number of helper functions available, like `elements()` that repeats everything in the `Counter` by the how many times it has been counted:
```terminal
>>> count = Counter("Hello world, my name is Simone")

>>> list(count.elements()) # .elements() return an iterable, so we'll expand it with list() constructor
['H',
 'e',
 'e',
 'e',
 'l',
 'l',
 'l',
 'o',
 'o',
 'o',
 ' ',
 ' ',
 ' ',
 ' ',
 ' ',
 'w',
 'r',
 'd',
 ',',
 'm',
 'm',
 'm',
 'y',
 'n',
 'n',
 'a',
 'i',
 'i',
 's',
 'S']
```

An example usage of `elements()` is when you need an alternative way to populate a list with a default value some amount of times:
```terminal
>>> list(Counter(x=10).elements())
['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x']
```

Other methods:
```terminal
>>> count.most_common(3)
[(' ', 5), ('e', 3), ('l', 3)]

>>> count.total() # get a total for all elements encountered
30
```
# 2. `ChainMap`, `defaultdict`, `OrderedDict`
## 2.1. `defaultdict`
Dictionaries in Python are likely the best choice to use in a lot of situation, but they can still be a bit awkward to work with. Say, for example, we wanted to replicate the counter behaviour on our own:
```python
word_list = ["orange", "apple", "watermelon", "apple", "watermelon", "grape", "apple"]

counter = {}
for word in word_list:
    if word in counter:
        counter[word] +=1
    else:
        counter[word] = 1
```

Let's see the result:
```terminal
>>> counter
{'orange': 1, 'apple': 3, 'watermelon': 2, 'grape': 1}
```

This is a situation where `defaultdict` can help because we can specify what the default values should be:
```terminal
>>> from collections import defaultdict

>>> ct = defaultdict(int)
>>> ct
defaultdict(int, {})
```

Now, if you try to access a non-existing key of this data structure, we'll get the default value without raising a `KeyError` exception:
```terminal
>>> ct["apple"]
0

>>> ct
defaultdict(int, {'apple': 0})
```

Notice that `apple` now is a key of this dictionary-like data structure. This implies that we can set a value for these keys without checking and see if the value already exists:
```terminal
>>> ct["grape"] += 1

>>> ct
defaultdict(int, {'apple': 0, 'grape': 1})
```

Due of this behaviour, we can change the code above in a more concise one because we can remove the if statement that checks if the key exists in the dictionary:
```python
word_list = ["orange", "apple", "watermelon", "apple", "watermelon", "grape", "apple"]

counter = defaultdict(int)
for word in word_list:
        counter[word] +=1
```
## 2.2. `OrderedDict`
Prior to Python 3.7, dictionary order wasn't something that was guaranteed by the language itself. So, `OrderedDict` were used to guarantee a specific order with dictionaries. Since Python 3.7 dictionary ordering is now guaranteed, so `OrderedDict` aren't nearly as commonly used anymore. However, it does still have some interesting functionalities to know. Let's create a simple one:
```python
from collections import OrderedDict

tasks = [
    ("Task 1", "To do"),
    ("Task 2", "To do"),
    ("Task 3", "To do")
]

task_dict = OrderedDict(tasks)
task_dict["Task 2"] = "Complete"
```

One great functionality is that you can move around the orders of the keys. For instance, with `move_to_end()` method you can push down a key-value pair till the last key available:
```terminal
>>> task_dict.move_to_end("Task 2")
>>> task_dict
OrderedDict([('Task 1', 'To do'), ('Task 3', 'To do'), ('Task 2', 'Complete')])
```

We can also to the inverse. If you create a new key it goes, by default, to the end of the dictionaries but, if you set `last=False` in the `move_to_end()` method, it moves that key at the beginning of the dictionary:
```terminal
>>> task_dict["Task 4"] = "To do"
>>> task_dict.move_to_end("Task 4", last=False)
OrderedDict([('Task 4', 'To do'),
             ('Task 1', 'To do'),
             ('Task 3', 'To do'),
             ('Task 2', 'Complete')])
```
## 2.3. `ChainMap`
This dictionary helper is definitely under-utilized, but it's very powerful. `ChainMap` are a great way to **combine multiple dictionaries together** without having to create or update existing dictionary. Let's give an example:
```terminal
>>> from collections import ChainMap

>>> d1 = {"orange": 1, "apple": 3, "watermelon": 2, "grape": 1}
>>> d2 = {"banana": 1, "apple": 2, "grape": 1}

>>> cm = ChainMap(d1, d2)
>>> cm
ChainMap({'orange': 1, 'apple': 3, 'watermelon': 2, 'grape': 1}, {'banana': 1, 'apple': 2, 'grape': 1})
```

There are different rules you have to keep in mind when working with `ChainMap`:
+ there is a precedent order for the dictionaries within the map, meaning the earlier on the dictionaries added to the chain map, the higher priority it has. So, although `d1` and `d2` both have `apple`, if you access the value of `apple`, according to the chain map, we see we get the value from `d1`:
```terminal
>>> cm["apple"]
3
```
+ if we were to update this value, we see that `d1` and not `d2` has been modified:
```terminal
>>> cm["apple"] = 5
>>> cm
ChainMap({'orange': 1, 'apple': 5, 'watermelon': 2, 'grape': 1}, {'banana': 1, 'apple': 2, 'grape': 1})

>>> d1
{'orange': 1, 'apple': 5, 'watermelon': 2, 'grape': 1}
>>> d2
{'banana': 1, 'apple': 2, 'grape': 1}
```
15.30 to finish